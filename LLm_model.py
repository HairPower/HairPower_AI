# -*- coding: utf-8 -*-
"""LLm_model.pyì˜ ì‚¬ë³¸

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ym1pT8ZPAdCyz0lPMguX51C2QQncTOX4

# ì„¤ì¹˜
"""

!pip install FastAPI -q
!pip install uvicorn -q
!pip install fastapi nest-asyncio pyngrok uvicorn
!pip install --upgrade pyngrok
!pip install efficientnet_pytorch
!pip install mediapipe
!pip install langchain_community
!pip install openai
!pip install tiktoken
!pip install langgraph
!pip install langchain_openai

from google.colab import drive
drive.mount('/content/drive')

import os
import pyngrok as ngrok
from pyngrok import conf
os.environ["OPENAI_API_KEY"] = "YOUR_OPENAI_API_KEY"
os.environ["NGROK_AUTHTOKEN"] = "YOUR_NGROK_AUTHTOKEN"
!ngrok.set_auth_token(os.environ["NGROK_AUTHTOKEN"])

import torch
import torch.nn as nn
import torchvision.transforms as transforms
from efficientnet_pytorch import EfficientNet
from PIL import Image
import base64
from io import BytesIO
import IPython.display as display
import cv2
import mediapipe as mp
import math
import numpy as np
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import json
import openai
import pandas as pd
from langchain.chat_models import init_chat_model
from langchain_core.messages import HumanMessage, BaseMessage, AIMessage
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import START, MessagesState, StateGraph
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from typing import Sequence
from langgraph.graph.message import add_messages
from typing_extensions import Annotated, TypedDict
from langchain_community.chat_message_histories import SQLChatMessageHistory
from langchain_core.runnables.history import RunnableWithMessageHistory
from langchain_openai import ChatOpenAI
from fastapi import FastAPI, Query
import requests

"""# LLM ëª¨ë¸"""

import sqlite3
import json
from typing import TypedDict, Sequence
from langchain_core.messages import HumanMessage, AIMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI
from langchain.memory import ConversationBufferMemory
from langchain.memory.chat_message_histories import SQLChatMessageHistory

# DB ì—°ê²° í•¨ìˆ˜
def get_db_connection():
    return sqlite3.connect("HairPower.db")

# ìœ ì €ë³„ ëŒ€í™” ë©”ì‹œì§€ ì €ì¥
def save_message(user_id, message_type, message):
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        INSERT INTO ai_history (user_id, message_type, message)
        VALUES (?, ?, ?)
    ''', (user_id, message_type, message))

    conn.commit()
    conn.close()

# ìœ ì €ë³„ ëŒ€í™” ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
def get_chat_history(user_id):
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        SELECT message_type, message FROM ai_history
        WHERE user_id = ? ORDER BY id ASC
    ''', (user_id,))

    messages = cursor.fetchall()
    conn.close()

    chat_history = []
    for message_type, message in messages:
        if message_type == "human":
            chat_history.append(HumanMessage(message))
        else:
            chat_history.append(AIMessage(message))

    return chat_history

# OpenAI ê¸°ë°˜ í—¤ì–´ìŠ¤íƒ€ì¼ ì¶”ì²œ í´ë˜ìŠ¤
class HairstyleRecommender:
    class State(TypedDict):
        messages: Sequence[HumanMessage]
        gender: str
        user_features: list
        user_id: str
        question: str
        data: dict

    def __init__(self, model_name="gpt-4o"):
        self.llm = ChatOpenAI(model_name=model_name)
        self.memory = ConversationBufferMemory()

        self.prompt_template = ChatPromptTemplate.from_messages([
            ("system",
            "âœ¨ ë‹¹ì‹ ì€ í—¤ì–´ìŠ¤íƒ€ì¼ ì¶”ì²œ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. "
            "ì‚¬ìš©ìì˜ ì–¼êµ´ íŠ¹ì§•ê³¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ëœ ì •ë³´ë¥¼ ì°¸ê³ í•˜ì—¬ ìµœì ì˜ í—¤ì–´ìŠ¤íƒ€ì¼ì„ ì¶”ì²œí•˜ì„¸ìš”. "
            "ğŸ” ì¶”ì²œ ì´ìœ ë¥¼ ì‹œê°ì ìœ¼ë¡œ ë³´ê¸° ì‰½ê²Œ ì„¤ëª…í•˜ê³ , ì´ëª¨ì§€ë¥¼ í™œìš©í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì—¬ì£¼ì„¸ìš”. "
            "ğŸ’¬ ì‚¬ìš©ìê°€ ì¶”ê°€ ì§ˆë¬¸ì„ ì…ë ¥í•˜ë©´, ì§€ê¸ˆê¹Œì§€ì˜ ëŒ€í™”ë¥¼ ìš”ì•½í•œ í›„ í•´ë‹¹ ì§ˆë¬¸ì— ë‹µë³€ì„ ì œê³µí•˜ì„¸ìš”. \n\n"
            "ğŸ“Œ **ë°ì´í„°ë² ì´ìŠ¤ ì •ë³´:** {data}"
            ),

            MessagesPlaceholder(variable_name="history"),

            ("human",
            "ğŸ“¸ **ì‚¬ìš©ìì˜ ì–¼êµ´ íŠ¹ì§•:** {user_features} \n\n"
            "âœ… **ìœ„ íŠ¹ì§•ì„ ê³ ë ¤í•˜ì—¬ ê°€ì¥ ì í•©í•œ í—¤ì–´ìŠ¤íƒ€ì¼ì„ ì¶”ì²œí•´ì£¼ì„¸ìš”.** "
            "ğŸ’¡ ì™œ ì´ ìŠ¤íƒ€ì¼ì´ ì í•©í•œì§€ ìƒì„¸íˆ ì„¤ëª…í•˜ê³ , ì¶”ê°€ë¡œ ê³ ë ¤í•  ìˆ˜ ìˆëŠ” ìŠ¤íƒ€ì¼ë„ ì œì•ˆí•´ì£¼ì„¸ìš”. \n\n"
            "ğŸ’¬ ë§Œì•½ ì‚¬ìš©ìê°€ ì¶”ê°€ ì§ˆë¬¸ì„ ì…ë ¥í–ˆë‹¤ë©´, ì´ì „ ëŒ€í™”ë¥¼ ìš”ì•½í•œ í›„ í•´ë‹¹ ì§ˆë¬¸ì— ë‹µë³€í•´ì£¼ì„¸ìš”. \n\n"
            "â“ **ì‚¬ìš©ì ì§ˆë¬¸:** {question} \n\n"
            "ğŸ”¹ ì‘ë‹µì€ ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš”: \n\n"
            "```\n"
            "{{\n"
            '  "description": "í—¤ì–´ ìŠ¤íƒ€ì¼ ì¶”ì²œ ê²°ê³¼",\n'
            '  "content": {{\n'
            '    "type": "text/markdown",\n'
            '    "text": "### **ğŸ“Œ ì‚¬ìš©ì ì–¼êµ´ íŠ¹ì§•**  \n'
            '    > **{user_features}**  \n'
            '    \n'
            '    **ğŸ’‡â€â™€ï¸ ìµœì ì˜ ì¶”ì²œ ìŠ¤íƒ€ì¼:** **{{recommended_style}}**  \n'
            '    ---  \n'
            '    ## âœ¨ **ì¶”ì²œ ìŠ¤íƒ€ì¼: {{recommended_style}}**  \n'
            '    ### ğŸ’¡ **ì´ ìŠ¤íƒ€ì¼ì´ ì˜ ì–´ìš¸ë¦¬ëŠ” ì´ìœ :**  \n'
            '    âœ”ï¸ **ì´ë§ˆ ë³´ì™„** â†’ {{forehead_explanation}}  \n'
            '    âœ”ï¸ **ì½” ê¸¸ì´ ì¡°ì ˆ** â†’ {{nose_explanation}}  \n'
            '    âœ”ï¸ **ì–¼êµ´ ìœ¤ê³½ ê°œì„ ** â†’ {{face_shape_explanation}}  \n'
            '    ---  \n'
            '    ## ğŸ¨ **ì¶”ê°€ ì¶”ì²œ ìŠ¤íƒ€ì¼**  \n'
            '    ğŸ’â€â™€ï¸ **{{additional_style_1}}**  \n'
            '    âœ {{additional_style_1_explanation}}  \n'
            '    \n'
            '    âœ‚ï¸ **{{additional_style_2}}**  \n'
            '    âœ {{additional_style_2_explanation}}  \n'
            '    ---  \n'
            '    ## ğŸ” **ğŸ’¡ ìŠ¤íƒ€ì¼ ìœ ì§€ ê´€ë¦¬ íŒ**  \n'
            '    âœ”ï¸ **{{tip_1}}**  \n'
            '    âœ”ï¸ **{{tip_2}}**  \n'
            '    ğŸ“© **ë” ê¶ê¸ˆí•œ ì ì´ ìˆë‚˜ìš”? ì›í•˜ëŠ” ìŠ¤íƒ€ì¼ì„ ì¶”ê°€ë¡œ ì¶”ì²œí•´ë“œë¦´ ìˆ˜ ìˆì–´ìš”! ğŸ˜Š**"\n'
            "  }}\n"
            "}}\n"
            "```")
        ])


        # ì–¼êµ´ íŠ¹ì§• ë°ì´í„°ë² ì´ìŠ¤
        self.data = {
                "male_hairstyles": {
        "ëŒ„ë””íŒx": ["mid", "ë‚´ë¦° ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ë‹¤ìš´íŒ"],
        "ëŒ„ë””íŒo": ["mid", "ë‚´ë¦° ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì»¬"],
        "ìŠ¬ë¦­ëŒ„ë””": ["mid", "ë‚´ë¦° ë¨¸ë¦¬", "ë‹¤ìš´íŒ"],
        "ìš¸í”„": ["ë‚´ë¦° ë¨¸ë¦¬", "long", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ë’·ë¨¸ë¦¬", "ì»¬"],
        "ë¦¬ì  íŠ¸": ["short", "ì˜¬ë¦° ë¨¸ë¦¬", "ë‹¤ìš´íŒ"],
        "ê°€ì¼": ["mid", "ê°€ë¥´ë§ˆ ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ë¹„ëŒ€ì¹­"],
        "ë“œë¡­": ["short", "ë‚´ë¦° ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ë‹¤ìš´íŒ"],
        "í¬ë§ˆë“œ": ["short", "mid", "ì˜¬ë¦° ë¨¸ë¦¬", "ë‹¤ìš´íŒ"],
        "ë¡±ë¦¬í”„": ["long", "ê°€ë¥´ë§ˆ ë¨¸ë¦¬", "ì˜†ë³¼ë¥¨", "ì»¬", "ë’·ë¨¸ë¦¬"],
        "ì„¸ë¯¸ë¦¬í”„": ["mid", "long", "ê°€ë¥´ë§ˆ ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì˜†ë³¼ë¥¨", "ì»¬"],
        "ì‰ë„ìš°íŒ": ["mid", "ë‚´ë¦° ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì˜†ë³¼ë¥¨", "ì»¬"],
        "ì•„ì´ë¹„ë¦¬ê·¸": ["short", "ì˜¬ë¦° ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ë‹¤ìš´íŒ"],
        "5:5ê°€ë¥´ë§ˆíŒo": ["mid", "ê°€ë¥´ë§ˆ ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì»¬"],
        "5:5ê°€ë¥´ë§ˆíŒx": ["mid", "ê°€ë¥´ë§ˆ ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ë‹¤ìš´íŒ"],
        "íˆí”¼íŒ": ["long", "ë‚´ë¦° ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì˜†ë³¼ë¥¨", "ì»¬"],
        "í”Œë«": ["mid", "ì˜¬ë¦° ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ë¹„ëŒ€ì¹­", "ë‹¤ìš´íŒ"],
        "ìŠ¬ë¦½ë°±": ["ì˜¬ë¦° ë¨¸ë¦¬", "mid", "ë‹¤ìš´íŒ"],
        "í¬ë¡­ì»·": ["short", "ë‚´ë¦° ë¨¸ë¦¬", "ë‹¤ìš´íŒ"]
    },
    "girl_hairstyles": {
        "ì•oë‹¨ë°œí—ˆì‰¬ì»·": ["short", "ë‚´ë¦°ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì˜†ë³¼ë¥¨", "ë ˆì´ì–´ë“œ"],
        "ì•Xë‹¨ë°œí—ˆì‰¬ì»·": ["short", "ê°€ë¥´ë§ˆë¨¸ë¦¬", "ì˜†ë³¼ë¥¨", "ë ˆì´ì–´ë“œ"],
        "ë³´ë¸Œì»·": ["short", "ê°€ë¥´ë§ˆ", "ì˜†ë³¼ë¥¨", "ìœ„ë³¼ë¥¨"],
        "ì•oì¥ë°œíˆí”¼íŒ": ["long", "ë‚´ë¦°ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì˜†ë³¼ë¥¨", "ìœ„ë³¼ë¥¨", "ì»¬"],
        "ì•xì¥ë°œíˆí”¼íŒ": ["long", "ê°€ë¥´ë§ˆë¨¸ë¦¬", "ì˜†ë³¼ë¥¨", "ìœ„ë³¼ë¥¨", "ì»¬"],
        "ì•oí…ŒìŠ¬ì»·": ["short", "ë‚´ë¦°ë¨¸ë¦¬", "ìŠ¤íŠ¸ë ˆì´íŠ¸"],
        "ì•xí…ŒìŠ¬ì»·": ["short", "ê°€ë¥´ë§ˆë¨¸ë¦¬", "ìŠ¤íŠ¸ë ˆì´íŠ¸"],
        "ì•oíˆë©”ì»·": ["long", "ë‚´ë¦°ë¨¸ë¦¬", "ìŠ¤íŠ¸ë ˆì´íŠ¸", "ë‹¨ì°¨"],
        "ì•xíˆë©”ì»·": ["long", "ê°€ë¥´ë§ˆë¨¸ë¦¬", "ìŠ¤íŠ¸ë ˆì´íŠ¸", "ë‹¨ì°¨"],
        "ì•oë‹¨ë°œë ˆì´ì–´ë“œcì»¬": ["short", "ë‚´ë¦°ë¨¸ë¦¬", "ì•ë¨¸ë¦¬ë³¼ë¥¨", "ì˜†ë³¼ë¥¨", "ìœ„ë³¼ë¥¨", "ë ˆì´ì–´ë“œ", "ì»¬"],
        "ì•xë‹¨ë°œë ˆì´ì–´ë“œcì»¬": ["short", "ê°€ë¥´ë§ˆë¨¸ë¦¬", "ì˜†ë³¼ë¥¨", "ìœ„ë³¼ë¥¨", "ë ˆì´ì–´ë“œ", "ì»¬"]
    }
}


    def recommend_hairstyle(self, user_id: str, gender: str, user_features: list, question: str = ""):
        # ìœ ì €ë³„ ëŒ€í™” íˆìŠ¤í† ë¦¬ ê´€ë¦¬ (session_id ë³€ê²½)
        session_id = f"hairstyle_{user_id}"
        self.chat_message_history = SQLChatMessageHistory(session_id=session_id, connection_string="sqlite:///HairPower.db")

        # ìœ ì €ì˜ ëŒ€í™” íˆìŠ¤í† ë¦¬ ë¶ˆëŸ¬ì˜¤ê¸°
        chat_history = get_chat_history(user_id)

        # í˜„ì¬ ì…ë ¥ ë©”ì‹œì§€ ìƒì„±
        input_text = f"Gender: {gender}, Features: {', '.join(user_features)}"
        if question:
            input_text += f" | Question: {question}"

        input_messages = chat_history + [HumanMessage(input_text)]

        # ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥ (DBì— ì €ì¥)
        save_message(user_id, "human", input_text)

        # OpenAI API í˜¸ì¶œ
        prompt = self.prompt_template.invoke({
            "history": input_messages,
            "user_features": user_features,
            "question": question,
            "data": json.dumps(self.data, ensure_ascii=False)
        })

        response = self.llm.invoke(prompt)
        ai_response = response.content

        # AI ì‘ë‹µ ì €ì¥ (DBì— ì €ì¥)
        save_message(user_id, "ai", ai_response)

        return ai_response

# ì‹¤í–‰ ì½”ë“œ (í…ŒìŠ¤íŠ¸ìš©)
if __name__ == "__main__":
    recommender = HairstyleRecommender()
    user_id = "user123"
    gender = "male"
    user_features = ["ê¸´ ì–¼êµ´", "ì§§ì€ ì´ë§ˆ", "ê¸´ ì½”"]
    question = "ì–´ë–¤ í—¤ì–´ê°€ ì˜ ì–´ìš¸ë¦¬ë‚˜ìš”?"

    recommendation = recommender.recommend_hairstyle(user_id, gender, user_features, question)
    print("ì¶”ì²œ í—¤ì–´ìŠ¤íƒ€ì¼ ë° ë‹µë³€:", recommendation)

"""# ë¶„ì„ ëª¨ë¸"""

import torch
import torch.nn as nn
import cv2
import math
import numpy as np
import mediapipe as mp
import requests
import urllib.parse
from io import BytesIO
from PIL import Image
from torchvision import transforms
from efficientnet_pytorch import EfficientNet
import matplotlib.pyplot as plt  # ì¶”ê°€ëœ ë¶€ë¶„
class FaceAnalyzer:
    def __init__(self):
        self.model_path = "/content/drive/MyDrive/Colab Notebooks/ktb_colabnotebooks/HairPower/best_model_loss (1).pthì˜ ì‚¬ë³¸"
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        # ëª¨ë¸ ë¡œë“œ
        self.model = self.load_model()

    def calculate_distance(self, p1, p2):
        return math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)

    def load_model(self):
        """EfficientNet ê¸°ë°˜ í„± ë¶„ì„ ëª¨ë¸ ë¡œë“œ"""
        model = EfficientNet.from_pretrained('efficientnet-b4')
        model._fc = nn.Sequential(
            nn.Dropout(0.4),
            nn.BatchNorm1d(model._fc.in_features),
            nn.Linear(model._fc.in_features, 256),
            nn.BatchNorm1d(256),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(256, 3)
        )
        checkpoint = torch.load(self.model_path, map_location=self.device)
        model.load_state_dict(checkpoint, strict=False)
        model.to(self.device)
        model.eval()
        return model

    def load_image(self, image_path):
        """URL ë˜ëŠ” ë¡œì»¬ ê²½ë¡œì˜ ì´ë¯¸ì§€ë¥¼ ë¡œë“œ"""
        if isinstance(image_path, Image.Image):  # ì´ë¯¸ Image ê°ì²´ë¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
            return image_path

        if image_path.startswith("http"):  # ğŸ”¥ URL ì´ë¯¸ì§€ ì²˜ë¦¬
            decoded_url = urllib.parse.unquote(image_path)  # âœ… URL ë””ì½”ë”©
            response = requests.get(decoded_url)
            if response.status_code != 200:
                raise ValueError(f"ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (HTTP {response.status_code})")
            image = Image.open(BytesIO(response.content)).convert("RGB")  # ğŸ”¥ BytesIOë¡œ ë³€í™˜ í›„ PIL.Image ë¡œë“œ
            return image

        else:  # ë¡œì»¬ íŒŒì¼ ì²˜ë¦¬
            return Image.open(image_path).convert("RGB")

    def preprocess_image(self, image_path):
        """ì´ë¯¸ì§€ ì „ì²˜ë¦¬"""
        image = self.load_image(image_path)  # ğŸ”¥ URL ì§€ì›
        transform = transforms.Compose([
            transforms.Resize((224, 224)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ])
        return transform(image).unsqueeze(0).to(self.device)

    def predict_chin_shape(self, image_path):
        """í„± ëª¨ì–‘ ì˜ˆì¸¡"""
        input_image = self.preprocess_image(image_path)

        with torch.no_grad():
            output = self.model(input_image)

        class_labels = ['ì„¸ëª¨í˜•', 'ë‘¥ê·¼í˜•', 'ê°ì§„í˜•']
        predicted_class_index = torch.argmax(output, dim=1)

        return class_labels[predicted_class_index.item()]

    def process_image(self, image):
        """ì´ëª©êµ¬ë¹„ ë¹„ìœ¨ ë¶„ì„"""
        mp_face_mesh = mp.solutions.face_mesh
        result = {}

        if not isinstance(image, np.ndarray):
            image = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)  # PIL.Image -> OpenCV ë³€í™˜

        with mp_face_mesh.FaceMesh(static_image_mode=True, max_num_faces=1, refine_landmarks=True, min_detection_confidence=0.5) as face_mesh:
            results = face_mesh.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))

            if results.multi_face_landmarks:
                landmark_list = results.multi_face_landmarks[0].landmark

                # ê±°ë¦¬ ê³„ì‚°
                distance_10_9 = self.calculate_distance(landmark_list[10], landmark_list[9]) * 1.6
                distance_9_2 = self.calculate_distance(landmark_list[9], landmark_list[2])
                distance_2_152 = self.calculate_distance(landmark_list[2], landmark_list[152])

                total_distance = distance_10_9 + distance_9_2 + distance_2_152
                result['forehead'] = round(distance_10_9 / total_distance, 3)
                result['nose'] = round(distance_9_2 / total_distance, 3)
                result['chin'] = round(distance_2_152 / total_distance, 3)

                # ëˆˆ-ë¯¸ê°„ ê±°ë¦¬ ê³„ì‚°
                pairs = [(127, 130), (130, 155), (155, 463), (463, 263), (263, 356)]
                distances = [self.calculate_distance(landmark_list[p1], landmark_list[p2]) for p1, p2 in pairs]

                total_distance = sum(distances)
                result['eye_mid'] = round(distances[2] / total_distance, 3)

                # ì„¸ë¡œ-ê°€ë¡œ ê±°ë¦¬ ë¹„ìœ¨ ê³„ì‚°
                distance_10_152 = self.calculate_distance(landmark_list[10], landmark_list[152])
                distance_127_264 = self.calculate_distance(landmark_list[127], landmark_list[264])
                total_distance = distance_10_152 + distance_127_264
                result['vertical'] = round(distance_10_152 / total_distance, 3)

                return result
        return None

    def labeling(self, image_path):
        """ì–¼êµ´ íŠ¹ì§• ë¼ë²¨ë§"""
        result = self.process_image(self.load_image(image_path))

        if result is None:
            return []

        face_standard = {
            'forehead': {'Q1': 0.276, 'Q3': 0.299},
            'nose': {'Q1': 0.355, 'Q3': 0.375},
            'chin': {'Q1': 0.333, 'Q3': 0.363},
            'eye_mid': {'Q1': 0.233, 'Q3': 0.251},
            'vertical': {'Q1': 0.476, 'Q3': 0.542}
        }

        features_dict = {
            'forehead': 'ì´ë§ˆ',
            'nose': 'ì½”',
            'chin': 'í„±',
            'eye_mid': 'ë¯¸ê°„',
            'vertical': 'ì–¼êµ´'
        }

        labels = []
        for feature, value in result.items():
            if feature in face_standard:
                if value < face_standard[feature]['Q1']:
                    labels.append(f'ì§§ì€ {features_dict[feature]}')
                elif value > face_standard[feature]['Q3']:
                    labels.append(f'ê¸´ {features_dict[feature]}')

        return labels

    def analyze_face(self, image_path):
        """í„± ëª¨ì–‘ ë° ì´ëª©êµ¬ë¹„ ë¶„ì„ ìˆ˜í–‰"""
        if not isinstance(image_path, Image.Image):  # URL ë˜ëŠ” ê²½ë¡œê°€ ë“¤ì–´ì˜¤ë©´ ë¡œë“œ
            image = self.load_image(image_path)
        else:
            image = image_path  # ì´ë¯¸ Image ê°ì²´ì´ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©

        chin_shape_result = self.predict_chin_shape(image)
        facial_features = self.process_image(image)

        if facial_features is None:
            return {"error": "ì–¼êµ´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."}

        facial_labels = self.labeling(image_path)  # âœ… ê¸°ì¡´ label_facial_features() ëŒ€ì‹  labeling() ì‚¬ìš©

        # feature ë¦¬ìŠ¤íŠ¸ë¥¼ user_features ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
        feature_mapping = {
            "ì§§ì€ ì´ë§ˆ": "forehead",
            "ê¸´ ì´ë§ˆ": "forehead",

            "ì§§ì€ ì½”": "nose",
            "ê¸´ ì½”": "nose",

            "ì§§ì€ í„±": "chin",
            "ê¸´ í„±": "chin",

            "ì§§ì€ ë¯¸ê°„": "eye_mid",
            "ê¸´ ë¯¸ê°„": "eye_mid",

            "ì§§ì€ ì–¼êµ´": "vertical",
            "ê¸´ ì–¼êµ´": "vertical",

            "ì„¸ëª¨í˜•": "shape",
            "ë‘¥ê·¼í˜•": "shape",
            "ê°ì§„í˜•": "shape",
        }

        # ê¸°ë³¸ê°’ì„ "í‰ë²”í•œ"ìœ¼ë¡œ ì„¤ì •
        default_features = {
            "forehead": "í‰ë²”í•œ ì´ë§ˆ",
            "nose": "í‰ë²”í•œ ì½”",
            "chin": "í‰ë²”í•œ í„±",
            "eye_mid": "í‰ë²”í•œ ë¯¸ê°„",
            "vertical": "í‰ë²”í•œ ì–¼êµ´",
            "shape": "í‰ë²”í•œ ì–¼êµ´í˜•"
        }

        # ê¸°ë³¸ user_features ë”•ì…”ë„ˆë¦¬ (í‰ë²”í•œ ê°’ìœ¼ë¡œ ì´ˆê¸°í™”)
        user_features = default_features.copy()

        # feature ë¦¬ìŠ¤íŠ¸ì—ì„œ ê°’ ë§¤í•‘ (ë¨¼ì € ê°ì§€ëœ ê°’ë§Œ ì €ì¥)
        for feature in facial_labels:
            mapped_key = feature_mapping.get(feature)
            if mapped_key:
                user_features[mapped_key] = feature  # ê°ì§€ëœ ê°’ì´ ìˆìœ¼ë©´ ë®ì–´ì“°ê¸°

        # í„± ëª¨ì–‘ ê²°ê³¼ ì¶”ê°€
          # âœ… í„± ëª¨ì–‘ ê²°ê³¼ ë°˜ì˜
        user_features["shape"] = chin_shape_result  # âœ… ì–¼êµ´í˜•ì—ë„ í„± ëª¨ì–‘ ê²°ê³¼ ë°˜ì˜

        return {"user_features": user_features}




# âœ… í…ŒìŠ¤íŠ¸ ì‹¤í–‰
if __name__ == "__main__":
    analyzer = FaceAnalyzer()
    image_url = "https://hairpower12.s3.ap-northeast-2.amazonaws.com/1740561021303_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3.jpeg"
    result = analyzer.analyze_face(image_url)
    print(result)

"""# ì‹¤í–‰ ë¶€ë¶„"""

import sqlite3

# SQLite DB íŒŒì¼ ê²½ë¡œ
DB_PATH = "HairPower.db"

# ğŸ“Œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë° í…Œì´ë¸” ìƒì„±
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # (1) user_features í…Œì´ë¸” ìƒì„± (ì‚¬ìš©ì ì–¼êµ´ íŠ¹ì§• ì €ì¥)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS user_features (
        user_id TEXT PRIMARY KEY,  -- ì‚¬ìš©ì ID (ê³ ìœ ê°’)
        gender TEXT,               -- ì„±ë³„
        features TEXT              -- ì–¼êµ´ íŠ¹ì§• (JSON í˜•íƒœë¡œ ì €ì¥)
    )
    ''')

    # (2) ai_history í…Œì´ë¸” ìƒì„± (AIì™€ì˜ ëŒ€í™” ê¸°ë¡ ì €ì¥)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS ai_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,  -- ë©”ì‹œì§€ ID (ìë™ ì¦ê°€)
        user_id TEXT,                          -- ì‚¬ìš©ì ID (user_featuresì˜ user_idì™€ ì—°ê²°)
        message_type TEXT CHECK (message_type IN ('human', 'ai')), -- ë©”ì‹œì§€ ìœ í˜• ('human': ì‚¬ìš©ì, 'ai': ì±—ë´‡)
        message TEXT                           -- ëŒ€í™” ë‚´ìš©
    )
    ''')

    # ë³€ê²½ì‚¬í•­ ì €ì¥ í›„ ì¢…ë£Œ
    conn.commit()
    conn.close()
    print("âœ… ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ìƒì„± ì™„ë£Œ!")

# ğŸ“Œ ì‹¤í–‰
if __name__ == "__main__":
    init_db()

import urllib.parse

!ngrok config add-authtoken YOUR_NGROCK_TOKEN

import nest_asyncio
from fastapi import FastAPI
from pyngrok import ngrok
import uvicorn
from fastapi import HTTPException

app = FastAPI()
face_analyz = FaceAnalyzer()
chatbot = HairstyleRecommender()
app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],
    allow_credentials=True,
    allow_methods=['*'],
    allow_headers=['*'],
)

from pydantic import BaseModel
from fastapi import FastAPI, HTTPException

app = FastAPI()

DB_PATH = "HairPower.db"
# ìœ ì €ì˜ ì–¼êµ´ íŠ¹ì§• ê°€ì ¸ì˜¤ê¸°
def get_user_features(user_id):
    conn = sqlite3.connect("HairPower.db")
    cursor = conn.cursor()

    cursor.execute('''
        SELECT gender, features FROM user_features WHERE user_id = ?
    ''', (user_id,))
    user_data = cursor.fetchone()
    conn.close()

    if user_data:
        gender, features_json = user_data
        user_features = json.loads(features_json)  # JSON ë¬¸ìì—´ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
        return gender, user_features
    else:
        return None, None  # ìœ ì € ë°ì´í„°ê°€ ì—†ìœ¼ë©´ None ë°˜í™˜

# ğŸ“Œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í•¨ìˆ˜
def get_db_connection():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row  # Dict í˜•íƒœë¡œ ë°˜í™˜
    return conn

# ğŸ“Œ ìš”ì²­ ë°ì´í„° ëª¨ë¸
class UploadPhotoRequest(BaseModel):
    user_id: str
    gender: str
    image_url: str

class UploadChatRequest(BaseModel):
    user_id: str
    message: str


@app.post('/upload-photo')
def upload_photo(data: UploadPhotoRequest):
    """
    ì‚¬ìš©ìì˜ IDì™€ ì‚¬ì§„ URLì„ ë°›ì•„ AI ë¶„ì„ì„ ìš”ì²­í•˜ëŠ” API
    - ìƒˆ ìœ ì €ëŠ” ìë™ ì €ì¥
    - ê¸°ì¡´ ìœ ì €ëŠ” ì—…ë°ì´íŠ¸ ê°€ëŠ¥
    """
    try:
        # ì–¼êµ´ íŠ¹ì§• ë¶„ì„ ì‹¤í–‰ (ì´ë¯¸ ê¸°ë³¸ê°’ì´ í¬í•¨ëœ ëª¨ë¸ ì‚¬ìš©)
        features = face_analyz.analyze_face(data.image_url)

        # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
        conn = get_db_connection()
        cursor = conn.cursor()

        # ê¸°ì¡´ ìœ ì € í™•ì¸
        cursor.execute("SELECT * FROM user_features WHERE user_id = ?", (data.user_id,))
        existing_user = cursor.fetchone()

        if existing_user:
            # ìœ ì € ì •ë³´ ì—…ë°ì´íŠ¸ (ì„±ë³„ ë³€ê²½ ê°€ëŠ¥)
            cursor.execute("UPDATE user_features SET gender = ?, features = ? WHERE user_id = ?",
                           (data.gender, json.dumps(features, ensure_ascii=False), data.user_id))
            message = "âœ… ìœ ì € ì •ë³´ ì—…ë°ì´íŠ¸ ì™„ë£Œ."
        else:
            # ìƒˆë¡œìš´ ìœ ì € ì¶”ê°€
            cursor.execute("INSERT INTO user_features (user_id, gender, features) VALUES (?, ?, ?)",
                           (data.user_id, data.gender, json.dumps(features, ensure_ascii=False)))
            message = "âœ… ì´ë¯¸ì§€ ì—…ë¡œë“œ ì™„ë£Œ. AI ë¶„ì„ ì§„í–‰ ì¤‘."

        conn.commit()
        conn.close()

        return {
            "status": "success",
            "user_id": data.user_id,
            "message": message,
            "features": features  # ğŸ”¥ ëª¨ë¸ì—ì„œ ë°˜í™˜í•œ ê°’ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        }

    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/select-story-image/{user_id}")
def get_user_features(user_id: str = Path(..., title="User ID")):
    """
    íŠ¹ì • ìœ ì €ì˜ ì–¼êµ´ íŠ¹ì§•ì„ ì¡°íšŒí•˜ëŠ” API
    - ì¡´ì¬í•˜ëŠ” ìœ ì €ë¼ë©´ ì–¼êµ´ íŠ¹ì§•ì„ ë°˜í™˜
    - ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìœ ì €ë¼ë©´ 404 ì—ëŸ¬ ë°˜í™˜
    """
    try:
        # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
        conn = get_db_connection()
        cursor = conn.cursor()

        # ìœ ì € íŠ¹ì§• ì¡°íšŒ
        cursor.execute("SELECT features FROM user_features WHERE user_id = ?", (user_id,))
        user_data = cursor.fetchone()

        conn.close()

        # ë°ì´í„°ê°€ ì—†ì„ ê²½ìš°
        if user_data is None:
            raise HTTPException(status_code=404, detail="âŒ í•´ë‹¹ ìœ ì €ì˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")

        # JSON í˜•íƒœë¡œ ë³€í™˜ (ë¬¸ìì—´ì„ JSON ê°ì²´ë¡œ ë³€í™˜)
        raw_features = user_data["features"]

        # âœ… ì¤‘ì²©ëœ JSONì„ í•´ê²°
        try:
            parsed_features = json.loads(raw_features)
            if "user_features" in parsed_features:
                parsed_features = parsed_features["user_features"]  # ì¤‘ì²©ëœ JSON êµ¬ì¡° í•´ê²°
        except json.JSONDecodeError:
            raise HTTPException(status_code=500, detail="âŒ ì €ì¥ëœ ë°ì´í„°ê°€ ì˜¬ë°”ë¥¸ JSON í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.")

        return {
            "user_id": user_id,
            "user_features": parsed_features
        }

    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))





# ì²« ë²ˆì§¸ ì§ˆë¬¸ ì—”ë“œí¬ì¸íŠ¸
@app.get("/get-story-result/{user_id}")
def first_question(user_id: str = Path(..., title="User ID")):
    """
    ìœ ì € IDë¥¼ ë°›ì•„ì„œ ì–¼êµ´ íŠ¹ì§•ì„ DBì—ì„œ ê°€ì ¸ì™€ ì²« ë²ˆì§¸ ì§ˆë¬¸ì„ ìë™ ìƒì„±í•˜ê³  AIì˜ ë‹µë³€ì„ ë°˜í™˜í•˜ëŠ” API
    """

    # ìœ ì € IDë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì„±ë³„ê³¼ ì–¼êµ´ íŠ¹ì§• ì¡°íšŒ
    gender, user_features = get_user_features(user_id)

    if not gender or not user_features:
        return {"error": "í•´ë‹¹ ì‚¬ìš©ì IDì˜ ì–¼êµ´ íŠ¹ì§• ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."}

    # ìœ ì €ë³„ ê¸°ì¡´ ëŒ€í™” ë‚´ì—­ í™•ì¸
    chat_history = get_chat_history(user_id)

    # ê¸°ì¡´ ëŒ€í™”ê°€ ì—†ë‹¤ë©´ ì²˜ìŒ ì§ˆë¬¸ ìƒì„±
    if not chat_history:
        first_question = "ë‚´ ì–¼êµ´ íŠ¹ì§•ë“¤ì„ ê¸°ë°˜ìœ¼ë¡œ ì–´ë–¤ í—¤ì–´ìŠ¤íƒ€ì¼ì´ ê°€ì¥ ì˜ ì–´ìš¸ë¦¬ëŠ”ì§€ ì•Œë ¤ì£¼ì„¸ìš”."
        save_message(user_id, "human", first_question)  # DBì— ì‚¬ìš©ì ì§ˆë¬¸ ì €ì¥
    else:
        # ê¸°ì¡´ ëŒ€í™”ê°€ ìˆë‹¤ë©´ ê°€ì¥ ìµœê·¼ ì§ˆë¬¸ì„ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜´
        first_question = chat_history[-1].content

    # AIì—ê²Œ ì¶”ì²œ ìš”ì²­
    ai_response = chatbot.recommend_hairstyle(user_id, gender, user_features, first_question)

    return {
        "description": "í—¤ì–´ ìŠ¤íƒ€ì¼ ì¶”ì²œ ê²°ê³¼",
        "user_id": user_id,
        "gender": gender,
        "user_features": user_features,
        "question": first_question,
        "content": {
            "type": "text/markdown",
            "text": ai_response
        }
    }

import json

@app.post("/chatbot/respond")
async def chat(data: UploadChatRequest):
    """
    ìœ ì €ì˜ ë©”ì‹œì§€ë¥¼ ë°›ì•„ì„œ AIì™€ ëŒ€í™”ë¥¼ ì´ì–´ê°€ëŠ” API
    """

    # âœ… user_id ê°€ì ¸ì˜¤ê¸°
    user_id = data.user_id

    # âœ… ìœ ì € IDë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì„±ë³„ê³¼ ì–¼êµ´ íŠ¹ì§• ì¡°íšŒ
    gender, user_features = get_user_features(user_id)

    if not gender or not user_features:
        raise HTTPException(status_code=404, detail="í•´ë‹¹ ì‚¬ìš©ì IDì˜ ì–¼êµ´ íŠ¹ì§• ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")

    # âœ… ìœ ì €ë³„ ê¸°ì¡´ ëŒ€í™” ë‚´ì—­ í™•ì¸
    chat_history = get_chat_history(user_id)

    # âœ… ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥ (DBì— ì €ì¥)
    save_message(user_id, "human", data.message)

    # âœ… AIì—ê²Œ ì¶”ì²œ ìš”ì²­
    ai_response = chatbot.recommend_hairstyle(user_id, gender, user_features, data.message)

    # âœ… ë§Œì•½ ai_responseê°€ JSON ë¬¸ìì—´ì´ë¼ë©´, íŒŒì‹±í•˜ì—¬ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
    if isinstance(ai_response, str):
        try:
            ai_response = json.loads(ai_response)  # ë¬¸ìì—´ JSONì„ íŒŒì‹±
        except json.JSONDecodeError:
            pass  # JSONì´ ì•„ë‹ ê²½ìš° ê·¸ëŒ€ë¡œ ë‘ 

    # âœ… JSONì´ë“  ë¬¸ìì—´ì´ë“  "response" í‚¤ë¡œ ë°˜í™˜
    return {"response": ai_response}


@app.get("/")
async def root():

    return {"message": "ì„œë²„ê°€ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤."}

if __name__ == "__main__":
    nest_asyncio.apply()  # Jupyter í™˜ê²½ì—ì„œ ì‹¤í–‰ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •


    ngrok_tunnel = ngrok.connect(3000)
    print("ngrok Public URL:", ngrok_tunnel.public_url)

    # FastAPI ì„œë²„ ì‹¤í–‰
    uvicorn.run(app, host="0.0.0.0", port=3000)

import sqlite3

DB_PATH = "HairPower.db"

def check_db_integrity():
    """ë°ì´í„°ë² ì´ìŠ¤ ë¬´ê²°ì„± ê²€ì‚¬"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("PRAGMA integrity_check;")
    result = cursor.fetchall()
    conn.close()

    if result[0][0] == "ok":
        print("âœ… ë°ì´í„°ë² ì´ìŠ¤ê°€ ì •ìƒì…ë‹ˆë‹¤.")
    else:
        print("âŒ ë°ì´í„°ë² ì´ìŠ¤ê°€ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤. ë³µêµ¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        print(result)

check_db_integrity()