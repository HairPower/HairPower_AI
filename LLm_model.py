# -*- coding: utf-8 -*-
"""LLm_model.py의 사본

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ym1pT8ZPAdCyz0lPMguX51C2QQncTOX4

# 설치
"""

!pip install FastAPI -q
!pip install uvicorn -q
!pip install fastapi nest-asyncio pyngrok uvicorn
!pip install --upgrade pyngrok
!pip install efficientnet_pytorch
!pip install mediapipe
!pip install langchain_community
!pip install openai
!pip install tiktoken
!pip install langgraph
!pip install langchain_openai

from google.colab import drive
drive.mount('/content/drive')

import os
import pyngrok as ngrok
from pyngrok import conf
os.environ["OPENAI_API_KEY"] = "YOUR_OPENAI_API_KEY"
os.environ["NGROK_AUTHTOKEN"] = "YOUR_NGROK_AUTHTOKEN"
!ngrok.set_auth_token(os.environ["NGROK_AUTHTOKEN"])

import torch
import torch.nn as nn
import torchvision.transforms as transforms
from efficientnet_pytorch import EfficientNet
from PIL import Image
import base64
from io import BytesIO
import IPython.display as display
import cv2
import mediapipe as mp
import math
import numpy as np
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import json
import openai
import pandas as pd
from langchain.chat_models import init_chat_model
from langchain_core.messages import HumanMessage, BaseMessage, AIMessage
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import START, MessagesState, StateGraph
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from typing import Sequence
from langgraph.graph.message import add_messages
from typing_extensions import Annotated, TypedDict
from langchain_community.chat_message_histories import SQLChatMessageHistory
from langchain_core.runnables.history import RunnableWithMessageHistory
from langchain_openai import ChatOpenAI
from fastapi import FastAPI, Query
import requests

"""# LLM 모델"""

import sqlite3
import json
from typing import TypedDict, Sequence
from langchain_core.messages import HumanMessage, AIMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI
from langchain.memory import ConversationBufferMemory
from langchain.memory.chat_message_histories import SQLChatMessageHistory

# DB 연결 함수
def get_db_connection():
    return sqlite3.connect("HairPower.db")

# 유저별 대화 메시지 저장
def save_message(user_id, message_type, message):
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        INSERT INTO ai_history (user_id, message_type, message)
        VALUES (?, ?, ?)
    ''', (user_id, message_type, message))

    conn.commit()
    conn.close()

# 유저별 대화 기록 불러오기
def get_chat_history(user_id):
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute('''
        SELECT message_type, message FROM ai_history
        WHERE user_id = ? ORDER BY id ASC
    ''', (user_id,))

    messages = cursor.fetchall()
    conn.close()

    chat_history = []
    for message_type, message in messages:
        if message_type == "human":
            chat_history.append(HumanMessage(message))
        else:
            chat_history.append(AIMessage(message))

    return chat_history

# OpenAI 기반 헤어스타일 추천 클래스
class HairstyleRecommender:
    class State(TypedDict):
        messages: Sequence[HumanMessage]
        gender: str
        user_features: list
        user_id: str
        question: str
        data: dict

    def __init__(self, model_name="gpt-4o"):
        self.llm = ChatOpenAI(model_name=model_name)
        self.memory = ConversationBufferMemory()

        self.prompt_template = ChatPromptTemplate.from_messages([
            ("system",
            "✨ 당신은 헤어스타일 추천 전문가입니다. "
            "사용자의 얼굴 특징과 데이터베이스에 저장된 정보를 참고하여 최적의 헤어스타일을 추천하세요. "
            "🔍 추천 이유를 시각적으로 보기 쉽게 설명하고, 이모지를 활용하여 가독성을 높여주세요. "
            "💬 사용자가 추가 질문을 입력하면, 지금까지의 대화를 요약한 후 해당 질문에 답변을 제공하세요. \n\n"
            "📌 **데이터베이스 정보:** {data}"
            ),

            MessagesPlaceholder(variable_name="history"),

            ("human",
            "📸 **사용자의 얼굴 특징:** {user_features} \n\n"
            "✅ **위 특징을 고려하여 가장 적합한 헤어스타일을 추천해주세요.** "
            "💡 왜 이 스타일이 적합한지 상세히 설명하고, 추가로 고려할 수 있는 스타일도 제안해주세요. \n\n"
            "💬 만약 사용자가 추가 질문을 입력했다면, 이전 대화를 요약한 후 해당 질문에 답변해주세요. \n\n"
            "❓ **사용자 질문:** {question} \n\n"
            "🔹 응답은 다음 JSON 형식으로 작성하세요: \n\n"
            "```\n"
            "{{\n"
            '  "description": "헤어 스타일 추천 결과",\n'
            '  "content": {{\n'
            '    "type": "text/markdown",\n'
            '    "text": "### **📌 사용자 얼굴 특징**  \n'
            '    > **{user_features}**  \n'
            '    \n'
            '    **💇‍♀️ 최적의 추천 스타일:** **{{recommended_style}}**  \n'
            '    ---  \n'
            '    ## ✨ **추천 스타일: {{recommended_style}}**  \n'
            '    ### 💡 **이 스타일이 잘 어울리는 이유:**  \n'
            '    ✔️ **이마 보완** → {{forehead_explanation}}  \n'
            '    ✔️ **코 길이 조절** → {{nose_explanation}}  \n'
            '    ✔️ **얼굴 윤곽 개선** → {{face_shape_explanation}}  \n'
            '    ---  \n'
            '    ## 🎨 **추가 추천 스타일**  \n'
            '    💁‍♀️ **{{additional_style_1}}**  \n'
            '    ➜ {{additional_style_1_explanation}}  \n'
            '    \n'
            '    ✂️ **{{additional_style_2}}**  \n'
            '    ➜ {{additional_style_2_explanation}}  \n'
            '    ---  \n'
            '    ## 🔎 **💡 스타일 유지 관리 팁**  \n'
            '    ✔️ **{{tip_1}}**  \n'
            '    ✔️ **{{tip_2}}**  \n'
            '    📩 **더 궁금한 점이 있나요? 원하는 스타일을 추가로 추천해드릴 수 있어요! 😊**"\n'
            "  }}\n"
            "}}\n"
            "```")
        ])


        # 얼굴 특징 데이터베이스
        self.data = {
                "male_hairstyles": {
        "댄디펌x": ["mid", "내린 머리", "앞머리볼륨", "다운펌"],
        "댄디펌o": ["mid", "내린 머리", "앞머리볼륨", "컬"],
        "슬릭댄디": ["mid", "내린 머리", "다운펌"],
        "울프": ["내린 머리", "long", "앞머리볼륨", "뒷머리", "컬"],
        "리젠트": ["short", "올린 머리", "다운펌"],
        "가일": ["mid", "가르마 머리", "앞머리볼륨", "비대칭"],
        "드롭": ["short", "내린 머리", "앞머리볼륨", "다운펌"],
        "포마드": ["short", "mid", "올린 머리", "다운펌"],
        "롱리프": ["long", "가르마 머리", "옆볼륨", "컬", "뒷머리"],
        "세미리프": ["mid", "long", "가르마 머리", "앞머리볼륨", "옆볼륨", "컬"],
        "쉐도우펌": ["mid", "내린 머리", "앞머리볼륨", "옆볼륨", "컬"],
        "아이비리그": ["short", "올린 머리", "앞머리볼륨", "다운펌"],
        "5:5가르마펌o": ["mid", "가르마 머리", "앞머리볼륨", "컬"],
        "5:5가르마펌x": ["mid", "가르마 머리", "앞머리볼륨", "다운펌"],
        "히피펌": ["long", "내린 머리", "앞머리볼륨", "옆볼륨", "컬"],
        "플랫": ["mid", "올린 머리", "앞머리볼륨", "비대칭", "다운펌"],
        "슬립백": ["올린 머리", "mid", "다운펌"],
        "크롭컷": ["short", "내린 머리", "다운펌"]
    },
    "girl_hairstyles": {
        "앞o단발허쉬컷": ["short", "내린머리", "앞머리볼륨", "옆볼륨", "레이어드"],
        "앞X단발허쉬컷": ["short", "가르마머리", "옆볼륨", "레이어드"],
        "보브컷": ["short", "가르마", "옆볼륨", "위볼륨"],
        "앞o장발히피펌": ["long", "내린머리", "앞머리볼륨", "옆볼륨", "위볼륨", "컬"],
        "앞x장발히피펌": ["long", "가르마머리", "옆볼륨", "위볼륨", "컬"],
        "앞o테슬컷": ["short", "내린머리", "스트레이트"],
        "앞x테슬컷": ["short", "가르마머리", "스트레이트"],
        "앞o히메컷": ["long", "내린머리", "스트레이트", "단차"],
        "앞x히메컷": ["long", "가르마머리", "스트레이트", "단차"],
        "앞o단발레이어드c컬": ["short", "내린머리", "앞머리볼륨", "옆볼륨", "위볼륨", "레이어드", "컬"],
        "앞x단발레이어드c컬": ["short", "가르마머리", "옆볼륨", "위볼륨", "레이어드", "컬"]
    }
}


    def recommend_hairstyle(self, user_id: str, gender: str, user_features: list, question: str = ""):
        # 유저별 대화 히스토리 관리 (session_id 변경)
        session_id = f"hairstyle_{user_id}"
        self.chat_message_history = SQLChatMessageHistory(session_id=session_id, connection_string="sqlite:///HairPower.db")

        # 유저의 대화 히스토리 불러오기
        chat_history = get_chat_history(user_id)

        # 현재 입력 메시지 생성
        input_text = f"Gender: {gender}, Features: {', '.join(user_features)}"
        if question:
            input_text += f" | Question: {question}"

        input_messages = chat_history + [HumanMessage(input_text)]

        # 사용자 메시지 저장 (DB에 저장)
        save_message(user_id, "human", input_text)

        # OpenAI API 호출
        prompt = self.prompt_template.invoke({
            "history": input_messages,
            "user_features": user_features,
            "question": question,
            "data": json.dumps(self.data, ensure_ascii=False)
        })

        response = self.llm.invoke(prompt)
        ai_response = response.content

        # AI 응답 저장 (DB에 저장)
        save_message(user_id, "ai", ai_response)

        return ai_response

# 실행 코드 (테스트용)
if __name__ == "__main__":
    recommender = HairstyleRecommender()
    user_id = "user123"
    gender = "male"
    user_features = ["긴 얼굴", "짧은 이마", "긴 코"]
    question = "어떤 헤어가 잘 어울리나요?"

    recommendation = recommender.recommend_hairstyle(user_id, gender, user_features, question)
    print("추천 헤어스타일 및 답변:", recommendation)

"""# 분석 모델"""

import torch
import torch.nn as nn
import cv2
import math
import numpy as np
import mediapipe as mp
import requests
import urllib.parse
from io import BytesIO
from PIL import Image
from torchvision import transforms
from efficientnet_pytorch import EfficientNet
import matplotlib.pyplot as plt  # 추가된 부분
class FaceAnalyzer:
    def __init__(self):
        self.model_path = "/content/drive/MyDrive/Colab Notebooks/ktb_colabnotebooks/HairPower/best_model_loss (1).pth의 사본"
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        # 모델 로드
        self.model = self.load_model()

    def calculate_distance(self, p1, p2):
        return math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)

    def load_model(self):
        """EfficientNet 기반 턱 분석 모델 로드"""
        model = EfficientNet.from_pretrained('efficientnet-b4')
        model._fc = nn.Sequential(
            nn.Dropout(0.4),
            nn.BatchNorm1d(model._fc.in_features),
            nn.Linear(model._fc.in_features, 256),
            nn.BatchNorm1d(256),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(256, 3)
        )
        checkpoint = torch.load(self.model_path, map_location=self.device)
        model.load_state_dict(checkpoint, strict=False)
        model.to(self.device)
        model.eval()
        return model

    def load_image(self, image_path):
        """URL 또는 로컬 경로의 이미지를 로드"""
        if isinstance(image_path, Image.Image):  # 이미 Image 객체라면 그대로 반환
            return image_path

        if image_path.startswith("http"):  # 🔥 URL 이미지 처리
            decoded_url = urllib.parse.unquote(image_path)  # ✅ URL 디코딩
            response = requests.get(decoded_url)
            if response.status_code != 200:
                raise ValueError(f"이미지를 불러올 수 없습니다. (HTTP {response.status_code})")
            image = Image.open(BytesIO(response.content)).convert("RGB")  # 🔥 BytesIO로 변환 후 PIL.Image 로드
            return image

        else:  # 로컬 파일 처리
            return Image.open(image_path).convert("RGB")

    def preprocess_image(self, image_path):
        """이미지 전처리"""
        image = self.load_image(image_path)  # 🔥 URL 지원
        transform = transforms.Compose([
            transforms.Resize((224, 224)),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ])
        return transform(image).unsqueeze(0).to(self.device)

    def predict_chin_shape(self, image_path):
        """턱 모양 예측"""
        input_image = self.preprocess_image(image_path)

        with torch.no_grad():
            output = self.model(input_image)

        class_labels = ['세모형', '둥근형', '각진형']
        predicted_class_index = torch.argmax(output, dim=1)

        return class_labels[predicted_class_index.item()]

    def process_image(self, image):
        """이목구비 비율 분석"""
        mp_face_mesh = mp.solutions.face_mesh
        result = {}

        if not isinstance(image, np.ndarray):
            image = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)  # PIL.Image -> OpenCV 변환

        with mp_face_mesh.FaceMesh(static_image_mode=True, max_num_faces=1, refine_landmarks=True, min_detection_confidence=0.5) as face_mesh:
            results = face_mesh.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))

            if results.multi_face_landmarks:
                landmark_list = results.multi_face_landmarks[0].landmark

                # 거리 계산
                distance_10_9 = self.calculate_distance(landmark_list[10], landmark_list[9]) * 1.6
                distance_9_2 = self.calculate_distance(landmark_list[9], landmark_list[2])
                distance_2_152 = self.calculate_distance(landmark_list[2], landmark_list[152])

                total_distance = distance_10_9 + distance_9_2 + distance_2_152
                result['forehead'] = round(distance_10_9 / total_distance, 3)
                result['nose'] = round(distance_9_2 / total_distance, 3)
                result['chin'] = round(distance_2_152 / total_distance, 3)

                # 눈-미간 거리 계산
                pairs = [(127, 130), (130, 155), (155, 463), (463, 263), (263, 356)]
                distances = [self.calculate_distance(landmark_list[p1], landmark_list[p2]) for p1, p2 in pairs]

                total_distance = sum(distances)
                result['eye_mid'] = round(distances[2] / total_distance, 3)

                # 세로-가로 거리 비율 계산
                distance_10_152 = self.calculate_distance(landmark_list[10], landmark_list[152])
                distance_127_264 = self.calculate_distance(landmark_list[127], landmark_list[264])
                total_distance = distance_10_152 + distance_127_264
                result['vertical'] = round(distance_10_152 / total_distance, 3)

                return result
        return None

    def labeling(self, image_path):
        """얼굴 특징 라벨링"""
        result = self.process_image(self.load_image(image_path))

        if result is None:
            return []

        face_standard = {
            'forehead': {'Q1': 0.276, 'Q3': 0.299},
            'nose': {'Q1': 0.355, 'Q3': 0.375},
            'chin': {'Q1': 0.333, 'Q3': 0.363},
            'eye_mid': {'Q1': 0.233, 'Q3': 0.251},
            'vertical': {'Q1': 0.476, 'Q3': 0.542}
        }

        features_dict = {
            'forehead': '이마',
            'nose': '코',
            'chin': '턱',
            'eye_mid': '미간',
            'vertical': '얼굴'
        }

        labels = []
        for feature, value in result.items():
            if feature in face_standard:
                if value < face_standard[feature]['Q1']:
                    labels.append(f'짧은 {features_dict[feature]}')
                elif value > face_standard[feature]['Q3']:
                    labels.append(f'긴 {features_dict[feature]}')

        return labels

    def analyze_face(self, image_path):
        """턱 모양 및 이목구비 분석 수행"""
        if not isinstance(image_path, Image.Image):  # URL 또는 경로가 들어오면 로드
            image = self.load_image(image_path)
        else:
            image = image_path  # 이미 Image 객체이면 그대로 사용

        chin_shape_result = self.predict_chin_shape(image)
        facial_features = self.process_image(image)

        if facial_features is None:
            return {"error": "얼굴이 감지되지 않았습니다."}

        facial_labels = self.labeling(image_path)  # ✅ 기존 label_facial_features() 대신 labeling() 사용

        # feature 리스트를 user_features 딕셔너리로 변환
        feature_mapping = {
            "짧은 이마": "forehead",
            "긴 이마": "forehead",

            "짧은 코": "nose",
            "긴 코": "nose",

            "짧은 턱": "chin",
            "긴 턱": "chin",

            "짧은 미간": "eye_mid",
            "긴 미간": "eye_mid",

            "짧은 얼굴": "vertical",
            "긴 얼굴": "vertical",

            "세모형": "shape",
            "둥근형": "shape",
            "각진형": "shape",
        }

        # 기본값을 "평범한"으로 설정
        default_features = {
            "forehead": "평범한 이마",
            "nose": "평범한 코",
            "chin": "평범한 턱",
            "eye_mid": "평범한 미간",
            "vertical": "평범한 얼굴",
            "shape": "평범한 얼굴형"
        }

        # 기본 user_features 딕셔너리 (평범한 값으로 초기화)
        user_features = default_features.copy()

        # feature 리스트에서 값 매핑 (먼저 감지된 값만 저장)
        for feature in facial_labels:
            mapped_key = feature_mapping.get(feature)
            if mapped_key:
                user_features[mapped_key] = feature  # 감지된 값이 있으면 덮어쓰기

        # 턱 모양 결과 추가
          # ✅ 턱 모양 결과 반영
        user_features["shape"] = chin_shape_result  # ✅ 얼굴형에도 턱 모양 결과 반영

        return {"user_features": user_features}




# ✅ 테스트 실행
if __name__ == "__main__":
    analyzer = FaceAnalyzer()
    image_url = "https://hairpower12.s3.ap-northeast-2.amazonaws.com/1740561021303_%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3.jpeg"
    result = analyzer.analyze_face(image_url)
    print(result)

"""# 실행 부분"""

import sqlite3

# SQLite DB 파일 경로
DB_PATH = "HairPower.db"

# 📌 데이터베이스 연결 및 테이블 생성
def init_db():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # (1) user_features 테이블 생성 (사용자 얼굴 특징 저장)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS user_features (
        user_id TEXT PRIMARY KEY,  -- 사용자 ID (고유값)
        gender TEXT,               -- 성별
        features TEXT              -- 얼굴 특징 (JSON 형태로 저장)
    )
    ''')

    # (2) ai_history 테이블 생성 (AI와의 대화 기록 저장)
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS ai_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,  -- 메시지 ID (자동 증가)
        user_id TEXT,                          -- 사용자 ID (user_features의 user_id와 연결)
        message_type TEXT CHECK (message_type IN ('human', 'ai')), -- 메시지 유형 ('human': 사용자, 'ai': 챗봇)
        message TEXT                           -- 대화 내용
    )
    ''')

    # 변경사항 저장 후 종료
    conn.commit()
    conn.close()
    print("✅ 데이터베이스 테이블 생성 완료!")

# 📌 실행
if __name__ == "__main__":
    init_db()

import urllib.parse

!ngrok config add-authtoken YOUR_NGROCK_TOKEN

import nest_asyncio
from fastapi import FastAPI
from pyngrok import ngrok
import uvicorn
from fastapi import HTTPException

app = FastAPI()
face_analyz = FaceAnalyzer()
chatbot = HairstyleRecommender()
app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],
    allow_credentials=True,
    allow_methods=['*'],
    allow_headers=['*'],
)

from pydantic import BaseModel
from fastapi import FastAPI, HTTPException

app = FastAPI()

DB_PATH = "HairPower.db"
# 유저의 얼굴 특징 가져오기
def get_user_features(user_id):
    conn = sqlite3.connect("HairPower.db")
    cursor = conn.cursor()

    cursor.execute('''
        SELECT gender, features FROM user_features WHERE user_id = ?
    ''', (user_id,))
    user_data = cursor.fetchone()
    conn.close()

    if user_data:
        gender, features_json = user_data
        user_features = json.loads(features_json)  # JSON 문자열을 리스트로 변환
        return gender, user_features
    else:
        return None, None  # 유저 데이터가 없으면 None 반환

# 📌 데이터베이스 연결 함수
def get_db_connection():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row  # Dict 형태로 반환
    return conn

# 📌 요청 데이터 모델
class UploadPhotoRequest(BaseModel):
    user_id: str
    gender: str
    image_url: str

class UploadChatRequest(BaseModel):
    user_id: str
    message: str


@app.post('/upload-photo')
def upload_photo(data: UploadPhotoRequest):
    """
    사용자의 ID와 사진 URL을 받아 AI 분석을 요청하는 API
    - 새 유저는 자동 저장
    - 기존 유저는 업데이트 가능
    """
    try:
        # 얼굴 특징 분석 실행 (이미 기본값이 포함된 모델 사용)
        features = face_analyz.analyze_face(data.image_url)

        # 데이터베이스 연결
        conn = get_db_connection()
        cursor = conn.cursor()

        # 기존 유저 확인
        cursor.execute("SELECT * FROM user_features WHERE user_id = ?", (data.user_id,))
        existing_user = cursor.fetchone()

        if existing_user:
            # 유저 정보 업데이트 (성별 변경 가능)
            cursor.execute("UPDATE user_features SET gender = ?, features = ? WHERE user_id = ?",
                           (data.gender, json.dumps(features, ensure_ascii=False), data.user_id))
            message = "✅ 유저 정보 업데이트 완료."
        else:
            # 새로운 유저 추가
            cursor.execute("INSERT INTO user_features (user_id, gender, features) VALUES (?, ?, ?)",
                           (data.user_id, data.gender, json.dumps(features, ensure_ascii=False)))
            message = "✅ 이미지 업로드 완료. AI 분석 진행 중."

        conn.commit()
        conn.close()

        return {
            "status": "success",
            "user_id": data.user_id,
            "message": message,
            "features": features  # 🔥 모델에서 반환한 값을 그대로 사용
        }

    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/select-story-image/{user_id}")
def get_user_features(user_id: str = Path(..., title="User ID")):
    """
    특정 유저의 얼굴 특징을 조회하는 API
    - 존재하는 유저라면 얼굴 특징을 반환
    - 존재하지 않는 유저라면 404 에러 반환
    """
    try:
        # 데이터베이스 연결
        conn = get_db_connection()
        cursor = conn.cursor()

        # 유저 특징 조회
        cursor.execute("SELECT features FROM user_features WHERE user_id = ?", (user_id,))
        user_data = cursor.fetchone()

        conn.close()

        # 데이터가 없을 경우
        if user_data is None:
            raise HTTPException(status_code=404, detail="❌ 해당 유저의 데이터가 없습니다.")

        # JSON 형태로 변환 (문자열을 JSON 객체로 변환)
        raw_features = user_data["features"]

        # ✅ 중첩된 JSON을 해결
        try:
            parsed_features = json.loads(raw_features)
            if "user_features" in parsed_features:
                parsed_features = parsed_features["user_features"]  # 중첩된 JSON 구조 해결
        except json.JSONDecodeError:
            raise HTTPException(status_code=500, detail="❌ 저장된 데이터가 올바른 JSON 형식이 아닙니다.")

        return {
            "user_id": user_id,
            "user_features": parsed_features
        }

    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))





# 첫 번째 질문 엔드포인트
@app.get("/get-story-result/{user_id}")
def first_question(user_id: str = Path(..., title="User ID")):
    """
    유저 ID를 받아서 얼굴 특징을 DB에서 가져와 첫 번째 질문을 자동 생성하고 AI의 답변을 반환하는 API
    """

    # 유저 ID를 기반으로 성별과 얼굴 특징 조회
    gender, user_features = get_user_features(user_id)

    if not gender or not user_features:
        return {"error": "해당 사용자 ID의 얼굴 특징 데이터가 없습니다."}

    # 유저별 기존 대화 내역 확인
    chat_history = get_chat_history(user_id)

    # 기존 대화가 없다면 처음 질문 생성
    if not chat_history:
        first_question = "내 얼굴 특징들을 기반으로 어떤 헤어스타일이 가장 잘 어울리는지 알려주세요."
        save_message(user_id, "human", first_question)  # DB에 사용자 질문 저장
    else:
        # 기존 대화가 있다면 가장 최근 질문을 다시 불러옴
        first_question = chat_history[-1].content

    # AI에게 추천 요청
    ai_response = chatbot.recommend_hairstyle(user_id, gender, user_features, first_question)

    return {
        "description": "헤어 스타일 추천 결과",
        "user_id": user_id,
        "gender": gender,
        "user_features": user_features,
        "question": first_question,
        "content": {
            "type": "text/markdown",
            "text": ai_response
        }
    }

import json

@app.post("/chatbot/respond")
async def chat(data: UploadChatRequest):
    """
    유저의 메시지를 받아서 AI와 대화를 이어가는 API
    """

    # ✅ user_id 가져오기
    user_id = data.user_id

    # ✅ 유저 ID를 기반으로 성별과 얼굴 특징 조회
    gender, user_features = get_user_features(user_id)

    if not gender or not user_features:
        raise HTTPException(status_code=404, detail="해당 사용자 ID의 얼굴 특징 데이터가 없습니다.")

    # ✅ 유저별 기존 대화 내역 확인
    chat_history = get_chat_history(user_id)

    # ✅ 사용자 메시지 저장 (DB에 저장)
    save_message(user_id, "human", data.message)

    # ✅ AI에게 추천 요청
    ai_response = chatbot.recommend_hairstyle(user_id, gender, user_features, data.message)

    # ✅ 만약 ai_response가 JSON 문자열이라면, 파싱하여 딕셔너리로 변환
    if isinstance(ai_response, str):
        try:
            ai_response = json.loads(ai_response)  # 문자열 JSON을 파싱
        except json.JSONDecodeError:
            pass  # JSON이 아닐 경우 그대로 둠

    # ✅ JSON이든 문자열이든 "response" 키로 반환
    return {"response": ai_response}


@app.get("/")
async def root():

    return {"message": "서버가 정상적으로 실행 중입니다."}

if __name__ == "__main__":
    nest_asyncio.apply()  # Jupyter 환경에서 실행 가능하게 설정


    ngrok_tunnel = ngrok.connect(3000)
    print("ngrok Public URL:", ngrok_tunnel.public_url)

    # FastAPI 서버 실행
    uvicorn.run(app, host="0.0.0.0", port=3000)

import sqlite3

DB_PATH = "HairPower.db"

def check_db_integrity():
    """데이터베이스 무결성 검사"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("PRAGMA integrity_check;")
    result = cursor.fetchall()
    conn.close()

    if result[0][0] == "ok":
        print("✅ 데이터베이스가 정상입니다.")
    else:
        print("❌ 데이터베이스가 손상되었습니다. 복구가 필요합니다.")
        print(result)

check_db_integrity()